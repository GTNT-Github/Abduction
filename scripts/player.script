go.property("speed", 350)
go.property("touching_item", false)
touched_item = ""

function init(self)
	tables()
	-- Acquire Input Focus
	msg.post(".", "acquire_input_focus")

	-- Start Variable
	self.dir = vmath.vector3()
	self.correction = vmath.vector3()
	for i, v in pairs(collisions) do
		physics.set_maskbit("#player_bottom", v, true)
		physics.set_maskbit("#player_top", v, true)
	end

	for i, v in pairs(item_collision) do
		physics.set_maskbit("#player_bottom", v, true)
		physics.set_maskbit("#player_top", v, true)
	end
end


function update(self, dt)
	-- Walking
	local pos = go.get_position()
	go.set_position(pos + self.dir * self.speed * dt)

	--Setting correct idle
	if self.current_anim == hash("player_walk_left") then
		anim = hash("player_left_idle")
		
	elseif self.current_anim == hash("player_walk_right") then
		anim = hash("player_right_idle")
	
	end
	
	-- Detecting needed animation
	if self.dir.x > 0 then
		anim = hash("player_walk_left")
		
	elseif self.dir.x < 0 then
		anim = hash("player_walk_right")
		
	elseif self.dir.y > 0 then
		anim = hash("player_walk_right")
		
	elseif self.dir.y < 0 then
		anim = hash("player_walk_right")
	end

	-- Resets direction
	self.dir = vmath.vector3()  

	-- Play Animation
	if anim ~= self.current_anim then
		msg.post("#sprite", "play_animation", { id = anim })
		self.current_anim = anim
	end  


	-- Reset Variables
	self.correction = vmath.vector3()
	self.speed = 350
	local screen_pos = camera.world_to_screen(camera_id, go.get_position())
	self.touching_item = nil
	touched_item = nil


	-- Fleeing
	if screen_pos.x < 190 or screen_pos.x > 1100 or screen_pos.y < 200 or screen_pos.y > 600 then
		if fight then
			if can_flee == enemy_num[enemy-1] then
				msg.post("/fight", "disable_fight")
			else
				go.set_position(original_pos[enemy_num[enemy]])
			end
		end
	end

end

function on_input(self, action_id, action)
	
	-- Input detection
	if action_id == hash("down") then
		self.dir.y = -1
		
	elseif action_id == hash("up") then
		self.dir.y = 1
		
	elseif action_id == hash("left") then
		self.dir.x = -1
		
	elseif action_id == hash("right") then
		self.dir.x = 1
	elseif action_id == hash("pick_up") and action.pressed and does_object_exist("/"..tostring(touched_item)) then
		if self.touching_item then
			count = 0
			local full = false
			for k,v in pairs(inventory) do
				count = count+1
				if v == "-----" then
					msg.post("/printer#printer_example", "printtext", {line = item_pickup[touched_item] ,battle = false})
					go.delete("/"..touched_item)
					inventory[k] = item_name[touched_item]
					touching_item = false
					touched_item = nil
					if count == 5 then
						full = true
					end
					break
				end
			end
			if count == 5 and not full then
				msg.post("/printer#printer_example", "printtext", {line = 32,battle = false})
			end
		end
	end
end


function on_message(self, message_id, message, sender)

	--Wall collisions
	if message_id == hash("contact_point_response") then

		if message.other_group == hash("wall") then

			if message.distance > 0 then
				local proj = vmath.project(self.correction, message.normal * message.distance)

				if proj < 1 then
					local comp = (message.distance - message.distance * proj) * message.normal
					go.set_position(go.get_position() + comp)
					self.correction = self.correction + comp
				end
			end
		elseif message.other_group == hash("CellEnd") then
			msg.post("menu:/menu", "end")
		end
		
		-- Check for guard 
		for i, v in pairs(collisions) do
			if message.other_group == hash(collisions[i]) then
				if does_object_exist("/instance"..tonumber(i:sub(-1,-1))-1) then
					msg.post("/instance"..tonumber(i:sub(-1,-1))-1, "Guard")
				end
			end
		end

		for k, v in pairs(item_collision) do
			if message.other_group == hash(v) then
				self.touching_item = true
				touched_item = v
			end
		end
	end
end

-- Check of object exists
function does_object_exist(id)
    return pcall(function(id) go.get_position(id) end, id) == true
end