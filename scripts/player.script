SPEED = 1000
HP = 100

function init(self)
	
	-- Acquire Input Focus
	msg.post(".", "acquire_input_focus")

	-- Start Variable
	self.dir = vmath.vector3()
	self.correction = vmath.vector3()
end


function update(self, dt)
	
	-- Walking
	local pos = go.get_position()
	go.set_position(pos + self.dir * SPEED * dt)

	--Setting correct idle
	
	if self.current_anim == hash("player_walk_left") then
		anim = hash("player_left_idle")
		
	elseif self.current_anim == hash("player_walk_right") then
		anim = hash("player_right_idle")
	
	end
	
	-- Detecting needed animation
	if self.dir.x > 0 then
		anim = hash("player_walk_left")
		
	elseif self.dir.x < 0 then
		anim = hash("player_walk_right")
		
	elseif self.dir.y > 0 then
		anim = hash("player_walk_right")
		
	elseif self.dir.y < 0 then
		anim = hash("player_walk_right")
	end

	-- Resets direction
	self.dir = vmath.vector3()  

	-- Play Animation
	if anim ~= self.current_anim then
		msg.post("#sprite", "play_animation", { id = anim })
		self.current_anim = anim
	end  


	-- Reset Variables
	self.correction = vmath.vector3()
	speed = 500
	local screen_pos = camera.world_to_screen(camera_id, go.get_position())

	-- Fleeing
	if screen_pos.x < 190 or screen_pos.x > 1100 or screen_pos.y < 200 or screen_pos.y > 600 then
		if fight then
			if can_flee == enemy_num[enemy-1] then
				msg.post("/fight", "disable_fight")
			else
				go.set_position(original_pos[enemy_num[enemy]])
			end
		end
	end

end

function on_input(self, action_id, action)
	
	-- Input detection
	if action_id == hash("down") then
		self.dir.y = -1
		
	elseif action_id == hash("up") then
		self.dir.y = 1
		
	elseif action_id == hash("left") then
		self.dir.x = -1
		
	elseif action_id == hash("right") then
		self.dir.x = 1
	end
end


function on_message(self, message_id, message, sender)

	-- Slow when feet in sand
	if sender == msg.url(nil, go.get_id("player"), "player_bottom") then
		
		if message.other_group == hash("sand") then
			speed = 50
		end
	end

	--Stop at grass
		-- Handle collision
	if message.other_group == hash("wall") then
		if message.distance > 0 then
			-- First, project the accumulated correction onto
			-- the penetration vector
			local proj = vmath.project(self.correction, message.normal * message.distance)
			if proj < 1 then
			  -- Only care for projections that does not overshoot.
			  local comp = (message.distance - message.distance * proj) * message.normal
			  -- Apply compensation
			  go.set_position(go.get_position() + comp)
			  -- Accumulate correction done
			  self.correction = self.correction + comp
			end
		  end
	-- Check for guard 
	elseif message.other_group == hash("guard_1") then
		if does_object_exist("/instance0") then
			msg.post("/instance0", "guard_1")
		end
	elseif message.other_group == hash("guard_1_teleport") then
		if fight then
			go.set_position(original_pos[enemy_num[enemy]])
		end
	end
end

-- Check of object exists
function does_object_exist(id)
    return pcall(function(id) go.get_position(id) end, id) == true
end